# Nagarro's Ascent - Developer Onboarding Guide

**Welcome to the Nagarro's Ascent development team!** This document is your comprehensive guide to understanding the platform's architecture, codebase, and development workflows.

## 1. Introduction

**Nagarro's Ascent** (formerly AgentiMigrate) is an enterprise-grade AI-powered cloud migration assessment platform that automates complex cloud transformation assessments using specialized AI agents. The platform provides:

### Core Capabilities
*   **Phase 1 - Knowledge Base Creation:** Advanced document processing, parsing, and multi-modal knowledge graph population
*   **Phase 2A - Agent-Driven Assessment:** Specialized AI agent crews with 12+ years equivalent experience for comprehensive migration analysis
*   **Phase 2B - Interactive Q&A:** Lightweight RAG-powered chat interface for immediate document queries
*   **Professional Deliverables:** Executive-ready PDF/DOCX reports with embedded architecture diagrams
*   **Real-Time Command Center:** Modern React-based UI with comprehensive project management and monitoring

### Architecture Vision
Our goal is to provide a "Glass Box AI" experience with comprehensive logging, real-time monitoring, and full auditability of AI reasoning, while delivering enterprise-grade security, performance, and professional deliverables.

## 2. Getting Started: Current Setup Process

**Note:** The platform currently requires manual service startup. Automated scripts are being updated.

### Prerequisites
1. **Docker Desktop** - Ensure containers are running
2. **Python 3.11+** - For backend services
3. **Node.js 18+** - For frontend
4. **Git** - For version control

### Manual Startup Process
1. **Start Docker Containers:**
   ```bash
   docker-compose up -d postgres_service neo4j_service weaviate_service minio_service
   ```

2. **Start Services Individually:**
   ```bash
   # Terminal 1: Project Service (Port 8002)
   cd project-service
   python main.py

   # Terminal 2: Backend Service (Port 8000)
   cd backend
   python -m uvicorn app.main:app --host 0.0.0.0 --port 8000

   # Terminal 3: Reporting Service (Port 8001)
   cd reporting-service
   python main.py

   # Terminal 4: Frontend (Port 3000)
   cd frontend
   npm start
   ```

**Main Access Points:**
- **Frontend Command Center:** `http://localhost:3000`
- **Backend API:** `http://localhost:8000`
- **Project Service:** `http://localhost:8002`
- **Reporting Service:** `http://localhost:8001`

## 3. Codebase Structure

The project is a microservices architecture. Here's a breakdown of the key directories:

```
migration_platform_2/
├── backend/              # The "brains": FastAPI app for agent orchestration & core APIs.
├── frontend/             # The UI: React + TypeScript Command Center.
├── project-service/      # The "memory": FastAPI app for state management (projects, users).
├── reporting-service/    # The "scribe": FastAPI app for generating PDF/DOCX reports.
├── MegaParse/            # Third-party service for document parsing.
├── k8s/                  # Kubernetes manifests for production deployment.
├── docs/                 # All project documentation lives here.
├── logs/                 # Log files generated by the platform.
├── docker-compose.yml    # Defines how all services run and connect locally.
└── setup-platform.ps1    # The main script for setting up the local environment.
```

## 4. Services Deep Dive

### 4.1. `project-service` (The Source of Truth)

This service manages all persistent state with enhanced authentication and platform settings management.

*   **`main.py`**: Defines all FastAPI endpoints for CRUD operations on Projects, Users, Files, Settings, and Deliverables. Enhanced with UUID-based authentication and platform settings management.
*   **`database.py`**: PostgreSQL database schema using SQLAlchemy ORM with support for project lifecycle tracking and file metadata.
*   **`schemas.py`**: Pydantic models for API request/response validation with enhanced project status tracking.
*   **`auth.py`**: Enhanced authentication logic with UUID-based service users and JWT token management for service-to-service communication.

### 4.2. `backend` (The Orchestrator)

This is where the core AI logic happens with a dual-workflow architecture for optimal performance and user experience.

*   **`main.py`**: The main FastAPI application file with comprehensive logging and dual-workflow support:
    *   **File Upload**: `/upload/{project_id}` - Enhanced with MinIO integration and detailed progress tracking
    *   **Phase 1**: `/api/projects/{project_id}/process-documents` - Knowledge base creation endpoint
    *   **Phase 2A**: `/ws/run_assessment/{project_id}` - WebSocket for agent-driven assessment with real-time logging
    *   **Phase 2B**: `/api/projects/{project_id}/query` - Lightweight chat endpoint for immediate RAG queries
    *   **LLM Testing**: `/api/test-llm` - Comprehensive LLM connectivity testing with multi-provider support
    *   **Graph Visualization**: `/api/projects/{project_id}/graph` - Interactive dependency graph data

*   **`core/crew.py`**: Enhanced AI agent framework:
    *   **Specialized Agent Definitions**: Cloud Architect, Infrastructure Analyst, Compliance Officer, etc.
    *   **Enhanced Tools**: CloudServiceCatalogTool, ComplianceFrameworkTool, InfrastructureAnalysisTool
    *   **Robust Error Handling**: LLMInitializationError and comprehensive fallback mechanisms
    *   **Multi-Provider LLM Support**: OpenAI, Google Gemini, Anthropic Claude with automatic fallbacks

*   **`core/rag_service.py`**: Enhanced RAG pipeline with configurable vectorization:
    *   Weaviate integration with both local and cloud vectorizers
    *   Robust document chunking and embedding creation
    *   Semantic search with context-aware responses
    *   Error handling for vectorization mismatches

*   **`core/graph_service.py`**: Enhanced graph database management:
    *   Neo4j integration for IT landscape modeling
    *   Entity relationship mapping and dependency analysis
    *   Graph visualization data preparation

*   **MinIO Integration**: Object storage for all file operations:
    *   Reliable file upload and storage in `project-files` bucket
    *   Generated reports and artifacts in dedicated buckets
    *   Temporary processing workflows with proper cleanup

### 4.3. `frontend` (The Command Center)

This is a modern React application built with TypeScript and the Mantine component library, featuring comprehensive UI/UX improvements.

*   **`src/App.tsx`**: The main entry point with AssessmentProvider for global state management, routing setup, and responsive layout.
*   **`src/views/`**: Enhanced top-level components:
    *   `ProjectDetailView.tsx`: Comprehensive project management with real-time statistics and dual-workflow interface
    *   `DashboardView.tsx`: Project overview with enhanced metrics and professional layout
*   **`src/components/`**: Enhanced reusable components:
    *   `FileUpload.tsx`: Dual-workflow file upload with progress tracking, checkboxes, and comprehensive logging
    *   `project-detail/ChatInterface.tsx`: Enhanced RAG-powered chat connected to lightweight endpoint
    *   `project-detail/GraphVisualizer.tsx`: Interactive dependency graph with improved visualization
    *   `TestLLMModal.tsx`: Comprehensive LLM testing with multi-provider support and fallback mechanisms
    *   `DocumentTemplates.tsx`: Professional document generation with real backend integration
*   **`src/services/api.ts`**: Centralized API service with enhanced error handling and comprehensive endpoint coverage
*   **`src/contexts/AssessmentContext.tsx`**: Global state management for persistent assessment tracking across tabs
*   **Enhanced UI Features**:
    *   Draggable right panels with horizontal resizing
    *   Real-time assessment progress tracking
    *   Professional typography and spacing optimizations
    *   Responsive design with optimized panel widths
    *   Comprehensive error handling and user feedback
*   **`src/hooks/useProjects.ts`**: A custom React hook for managing project-related state, abstracting away the data fetching logic from the UI components.

## 5. Data Flow Walkthroughs

Understanding the data flow is key to understanding the system.

### Flow 1: Creating a New Project

1.  **User** fills out the form in `ProjectsView.tsx` and clicks "Create".
2.  The component calls a function from the `useProjects.ts` hook.
3.  The hook calls `apiService.createProject()`.
4.  `apiService` sends a `POST` request to the `backend`'s `/projects` endpoint.
5.  The `backend` endpoint proxies the request to the `project-service`'s `/projects` endpoint.
6.  The `project-service` validates the data, creates a new `ProjectModel` instance, associates it with the current user, and saves it to the **PostgreSQL** database.
7.  The response flows back up the chain to the UI, which updates to show the new project.

### Flow 2: Document Processing & Assessment (Current Implementation)

1.  **User** uploads files and clicks "Start Processing" in `FileUpload.tsx`.
2.  **Frontend** opens WebSocket connection to `backend` at `/ws/run_assessment/{project_id}`.
3.  **Backend** WebSocket handler execution:
    a. **Deduplication Check**: Checks for existing `processing_stats.json` to prevent duplicate processing
    b. **Data Cleanup**: If reprocessing, clears existing Weaviate embeddings and Neo4j entities
    c. **File Processing**: Processes uploaded files (currently using placeholder content)
    d. **Text Chunking**: Uses `RAGService` to chunk text and create embeddings
    e. **Vector Storage**: Stores embeddings in **Weaviate** with project-specific collections
    f. **Entity Extraction**: Extracts entities/relationships and stores in **Neo4j**
    g. **Statistics Tracking**: Saves processing stats to prevent future duplicates
4.  **CrewAI Initialization**: Creates assessment crew using YAML configurations
5.  **Agent Execution**: `crew.kickoff()` runs with `AgentLogStreamHandler` for real-time logging
6.  **Real-time Updates**: Agent actions streamed to frontend via WebSocket
7.  **Report Generation**: Final Markdown report generated by agents
8.  **Persistence**: Report saved to **PostgreSQL** and **Reporting Service** generates PDF/DOCX
9.  **Local & Cloud Storage**: Documents saved both locally and in **MinIO**

### Flow 3: Document Generation (Agent-Based)

1.  **User** selects document template in `DocumentTemplates.tsx`
2.  **Frontend** calls `/api/projects/{project_id}/generate-document` endpoint
3.  **Backend** validates project and LLM configuration
4.  **Agent Crew Creation**: Creates document generation crew (Research Specialist, Content Architect, Quality Reviewer)
5.  **RAG Integration**: Agents use `RAGQueryTool` and `GraphQueryTool` to access knowledge base
6.  **Document Creation**: Agents collaborate to generate professional document
7.  **Multi-format Output**: Document saved as Markdown, then converted to PDF/DOCX via **Reporting Service**
8.  **Dual Storage**: Documents stored both locally and in **MinIO** for redundancy

### Flow 4: Chat Functionality

1.  **User** asks question in `ChatInterface.tsx` or `FloatingChatWidget.tsx`
2.  **Frontend** calls `/api/projects/{project_id}/query` with question
3.  **Backend** initializes `RAGService` with project-specific LLM configuration
4.  **Vector Search**: Queries **Weaviate** for semantically similar content
5.  **LLM Synthesis**: Project's configured LLM synthesizes response from retrieved context
6.  **Response Delivery**: Answer returned to frontend and displayed in chat

## 6. How to Contribute

This section outlines common development tasks.

### How to Add a New Field to a Project (e.g., "priority")

1.  **Database (`project-service/database.py`):** Add `priority = Column(String(50), default="medium")` to the `ProjectModel` class.
2.  **API Schema (`project-service/schemas.py`):** Add `priority: Optional[str] = None` to the `ProjectCreate` and `ProjectUpdate` Pydantic models, and `priority: str` to the `ProjectResponse` model.
3.  **API Logic (`project-service/main.py`):** The existing code should handle the new field automatically due to how it uses Pydantic models.
4.  **Frontend UI (`frontend/src/views/ProjectsView.tsx`):** Add a new `Select` input for "Priority" in the project creation modal.
5.  **Frontend State (`frontend/src/hooks/useProjects.ts`):** Update the `createProject` function to pass the new `priority` field in the API call.
6.  **Frontend Display:** Add a new column to the projects table to display the priority.

### How to Add a New Tool for an Agent

1.  **Create the Tool Logic:** Create a new Python class or function that performs the desired action (e.g., a tool to get current stock prices). Let's say you create `get_stock_price(ticker: str)` in a new file `backend/app/core/financial_tools.py`.
2.  **Define the CrewAI Tool (`backend/app/core/crew.py`):**
    *   Import your new function.
    *   Create a new class that inherits from `BaseTool`:
        ```python
        from .financial_tools import get_stock_price

        class StockPriceTool(BaseTool):
            name: str = "Stock Price Tool"
            description: str = "Use this tool to get the current stock price for a given ticker symbol."

            def _run(self, ticker: str) -> str:
                return get_stock_price(ticker)
        ```
3.  **Instantiate and Assign the Tool (`backend/app/core/crew.py`):**
    *   Inside `create_assessment_crew()`, create an instance: `stock_tool = StockPriceTool()`.
    *   Add this tool to the `tools` list of the agent that should have access to it (e.g., the `Risk & Compliance Officer`).
4.  **Update the Agent's Goal/Task:** Modify the agent's `goal` or its `Task` description to explicitly mention that it can now use the "Stock Price Tool" to perform financial analysis. This is crucial for the LLM to know the tool exists and when to use it.

---

## 7. Recent Platform Enhancements (2025-07-29)

### New Features Added

**Global Log Pane:**
- Right-side collapsible panel accessible from any page
- Real-time logs for Platform, Agents, and Assessment activities
- Filtering, auto-scroll, and download capabilities
- Maximizable for detailed log analysis

**Service Management:**
- Platform services status panel in Settings
- Real-time health monitoring for all services
- Start/Stop/Restart capabilities for local services
- Live logs for service operations
- Service dependency tracking

**Project History:**
- Complete activity timeline for all project actions
- Detailed metadata for each activity
- Expandable details with JSON data
- Filtering by activity type
- Timestamp tracking for audit purposes

**Enhanced UI Components:**
- Improved navigation and user experience
- Better error handling and loading states
- Responsive design improvements
- Consistent styling across components

### Development Improvements

**Local Development:**
- Comprehensive `localdevstart.md` guide
- Step-by-step service startup instructions
- Troubleshooting section for common issues
- Rancher Desktop specific instructions

**Documentation:**
- `chatlog.md` for conversation history
- Updated architecture documentation
- Enhanced developer guides
- Code organization improvements

### How to Use New Features

**Accessing Logs:**
1. Click the collapsible arrow on the right side of any page
2. Select the log type (Platform/Agents/Assessment)
3. Use filters and controls to customize the view
4. Download logs for offline analysis

**Managing Services:**
1. Go to Settings → Platform Services tab
2. View real-time status of all services
3. Use action buttons to start/stop/restart services
4. Click logs button to view service-specific logs

**Viewing Project History:**
1. Open any project
2. Navigate to the History tab
3. Filter activities by type
4. Expand entries to see detailed information

---

**Happy Coding!**

This guide should provide a solid foundation for understanding and contributing to the **Nagarro's Ascent** platform. For any further questions, please refer to the `README.md`, `localdevstart.md`, or the source code itself.

---

## 8. Technology Stack Summary

### Frontend Technologies
- **React 18** with TypeScript for type safety and modern development
- **Mantine v7** for professional UI components and consistent design
- **React Router v6** for client-side routing and navigation
- **React Force Graph 2D** for interactive dependency visualizations
- **Axios** for HTTP client with comprehensive error handling
- **WebSockets** for real-time communication with backend services

### Backend Technologies  
- **FastAPI** with Python 3.11 for high-performance APIs
- **CrewAI Framework** for multi-agent AI orchestration
- **LangChain** for LLM integration and tool management
- **SQLAlchemy** for database ORM and relationship management
- **Pydantic** for data validation and serialization
- **JWT** for secure authentication and authorization

### AI & Machine Learning
- **OpenAI GPT-4** (primary LLM provider)
- **Google Gemini** and **Anthropic Claude** (secondary providers)
- **SentenceTransformers** for document embeddings
- **Weaviate** for vector similarity search
- **Neo4j** for graph-based dependency analysis

### Infrastructure & DevOps
- **Docker & Docker Compose** for containerized development
- **PostgreSQL 15** for relational data storage
- **MinIO** for S3-compatible object storage
- **Kubernetes** manifests for production deployment
- **Health Checks** and **Monitoring** for operational excellence

---

## 9. Development Best Practices

### Code Organization
- Follow **Domain-Driven Design** principles with clear service boundaries
- Use **TypeScript** for frontend type safety and better developer experience
- Implement **Pydantic models** for backend data validation
- Maintain **comprehensive error handling** across all services
- Write **self-documenting code** with clear variable and function names

### Testing Strategy
- **Unit Tests** for individual components and functions
- **Integration Tests** for service-to-service communication
- **End-to-End Tests** for complete user workflows
- **API Testing** with automated endpoint validation
- **Performance Testing** for document processing pipelines

### Security Considerations
- **JWT Authentication** with proper token expiration
- **Input Validation** using Pydantic schemas
- **API Key Encryption** for LLM provider credentials
- **RBAC Authorization** with user and admin roles
- **Audit Logging** for all user actions and agent activities

### Performance Optimization
- **Lazy Loading** of components and data
- **Connection Pooling** for database connections
- **Caching Strategies** for frequently accessed data
- **Asynchronous Processing** for long-running tasks
- **WebSocket Communication** for real-time updates

---

**Platform Version:** Nagarro's Ascent v2.0  
**Last Updated:** August 6, 2025  
**Documentation Status:** Current
