# Nagarro AgentiMigrate - Developer Onboarding Guide

**Welcome to the AgentiMigrate team!** This document is your guide to understanding the platform's architecture, codebase, and development workflows.

## 1. Introduction

AgentiMigrate is a GenAI-powered platform that automates cloud migration assessments using a dual-workflow architecture. It provides:

*   **Phase 1 - Knowledge Base Creation:** Document upload, parsing, and knowledge graph population
*   **Phase 2A - Agent-Driven Assessment:** Specialized AI agent crews for comprehensive migration analysis
*   **Phase 2B - Interactive Q&A:** Lightweight chat interface for immediate document queries

Our goal is to provide a "Glass Box AI" experience with comprehensive logging, real-time monitoring, and full auditability of AI reasoning.

## 2. Getting Started: Your First Launch

Your first step is to get the platform running locally. We have a fully automated script that handles everything.

1.  **Clone the repository.**
2.  **Navigate to the root directory.**
3.  **Run the setup script:**
    *   **On Windows (PowerShell):** `.\setup-platform.ps1`
    *   **On macOS/Linux (Bash):** `./build-optimized.sh` (you may need to `chmod +x *.sh` first)

The script will check prerequisites, create a `.env` file, prompt you for an API key, and build/launch all services. For a detailed walkthrough, see the `README.md`.

**Once running, the main access point is the Frontend Command Center: `http://localhost:3000`**

## 3. Codebase Structure

The project is a microservices architecture. Here's a breakdown of the key directories:

```
migration_platform_2/
├── backend/              # The "brains": FastAPI app for agent orchestration & core APIs.
├── frontend/             # The UI: React + TypeScript Command Center.
├── project-service/      # The "memory": FastAPI app for state management (projects, users).
├── reporting-service/    # The "scribe": FastAPI app for generating PDF/DOCX reports.
├── MegaParse/            # Third-party service for document parsing.
├── k8s/                  # Kubernetes manifests for production deployment.
├── docs/                 # All project documentation lives here.
├── logs/                 # Log files generated by the platform.
├── docker-compose.yml    # Defines how all services run and connect locally.
└── setup-platform.ps1    # The main script for setting up the local environment.
```

## 4. Services Deep Dive

### 4.1. `project-service` (The Source of Truth)

This service manages all persistent state with enhanced authentication and platform settings management.

*   **`main.py`**: Defines all FastAPI endpoints for CRUD operations on Projects, Users, Files, Settings, and Deliverables. Enhanced with UUID-based authentication and platform settings management.
*   **`database.py`**: PostgreSQL database schema using SQLAlchemy ORM with support for project lifecycle tracking and file metadata.
*   **`schemas.py`**: Pydantic models for API request/response validation with enhanced project status tracking.
*   **`auth.py`**: Enhanced authentication logic with UUID-based service users and JWT token management for service-to-service communication.

### 4.2. `backend` (The Orchestrator)

This is where the core AI logic happens with a dual-workflow architecture for optimal performance and user experience.

*   **`main.py`**: The main FastAPI application file with comprehensive logging and dual-workflow support:
    *   **File Upload**: `/upload/{project_id}` - Enhanced with MinIO integration and detailed progress tracking
    *   **Phase 1**: `/api/projects/{project_id}/process-documents` - Knowledge base creation endpoint
    *   **Phase 2A**: `/ws/run_assessment/{project_id}` - WebSocket for agent-driven assessment with real-time logging
    *   **Phase 2B**: `/api/projects/{project_id}/query` - Lightweight chat endpoint for immediate RAG queries
    *   **LLM Testing**: `/api/test-llm` - Comprehensive LLM connectivity testing with multi-provider support
    *   **Graph Visualization**: `/api/projects/{project_id}/graph` - Interactive dependency graph data

*   **`core/crew.py`**: Enhanced AI agent framework:
    *   **Specialized Agent Definitions**: Cloud Architect, Infrastructure Analyst, Compliance Officer, etc.
    *   **Enhanced Tools**: CloudServiceCatalogTool, ComplianceFrameworkTool, InfrastructureAnalysisTool
    *   **Robust Error Handling**: LLMInitializationError and comprehensive fallback mechanisms
    *   **Multi-Provider LLM Support**: OpenAI, Google Gemini, Anthropic Claude with automatic fallbacks

*   **`core/rag_service.py`**: Enhanced RAG pipeline with configurable vectorization:
    *   Weaviate integration with both local and cloud vectorizers
    *   Robust document chunking and embedding creation
    *   Semantic search with context-aware responses
    *   Error handling for vectorization mismatches

*   **`core/graph_service.py`**: Enhanced graph database management:
    *   Neo4j integration for IT landscape modeling
    *   Entity relationship mapping and dependency analysis
    *   Graph visualization data preparation

*   **MinIO Integration**: Object storage for all file operations:
    *   Reliable file upload and storage in `project-files` bucket
    *   Generated reports and artifacts in dedicated buckets
    *   Temporary processing workflows with proper cleanup

### 4.3. `frontend` (The Command Center)

This is a modern React application built with TypeScript and the Mantine component library, featuring comprehensive UI/UX improvements.

*   **`src/App.tsx`**: The main entry point with AssessmentProvider for global state management, routing setup, and responsive layout.
*   **`src/views/`**: Enhanced top-level components:
    *   `ProjectDetailView.tsx`: Comprehensive project management with real-time statistics and dual-workflow interface
    *   `DashboardView.tsx`: Project overview with enhanced metrics and professional layout
*   **`src/components/`**: Enhanced reusable components:
    *   `FileUpload.tsx`: Dual-workflow file upload with progress tracking, checkboxes, and comprehensive logging
    *   `project-detail/ChatInterface.tsx`: Enhanced RAG-powered chat connected to lightweight endpoint
    *   `project-detail/GraphVisualizer.tsx`: Interactive dependency graph with improved visualization
    *   `TestLLMModal.tsx`: Comprehensive LLM testing with multi-provider support and fallback mechanisms
    *   `DocumentTemplates.tsx`: Professional document generation with real backend integration
*   **`src/services/api.ts`**: Centralized API service with enhanced error handling and comprehensive endpoint coverage
*   **`src/contexts/AssessmentContext.tsx`**: Global state management for persistent assessment tracking across tabs
*   **Enhanced UI Features**:
    *   Draggable right panels with horizontal resizing
    *   Real-time assessment progress tracking
    *   Professional typography and spacing optimizations
    *   Responsive design with optimized panel widths
    *   Comprehensive error handling and user feedback
*   **`src/hooks/useProjects.ts`**: A custom React hook for managing project-related state, abstracting away the data fetching logic from the UI components.

## 5. Data Flow Walkthroughs

Understanding the data flow is key to understanding the system.

### Flow 1: Creating a New Project

1.  **User** fills out the form in `ProjectsView.tsx` and clicks "Create".
2.  The component calls a function from the `useProjects.ts` hook.
3.  The hook calls `apiService.createProject()`.
4.  `apiService` sends a `POST` request to the `backend`'s `/projects` endpoint.
5.  The `backend` endpoint proxies the request to the `project-service`'s `/projects` endpoint.
6.  The `project-service` validates the data, creates a new `ProjectModel` instance, associates it with the current user, and saves it to the **PostgreSQL** database.
7.  The response flows back up the chain to the UI, which updates to show the new project.

### Flow 2: Running an Assessment

1.  **User** uploads files and clicks "Start Assessment" in `FileManagement.tsx`.
2.  The **Frontend** opens a WebSocket connection to the `backend` at `/ws/run_assessment/{project_id}`.
3.  The `backend`'s WebSocket handler begins execution:
    a. It calls the **MegaParse** service to extract text from the uploaded files.
    b. It uses `RAGService` to chunk the text, create vector embeddings, and store them in **Weaviate**.
    c. It uses an AI agent via `RAGService` to extract entities and relationships and stores them in **Neo4j**.
    d. It calls `create_assessment_crew()` to initialize the AI agent team. The `AgentLogStreamHandler` is attached to the crew, pointing to our WebSocket.
4.  The `crew.kickoff()` method is called.
5.  As agents work, the `AgentLogStreamHandler` captures their actions and sends JSON messages over the **WebSocket** to the frontend's `LiveConsole.tsx`.
6.  When finished, the crew returns a final Markdown report.
7.  The `backend` handler saves this report to **PostgreSQL** via the `project-service`.
8.  The `backend` handler calls the **Reporting Service** to generate PDF/DOCX versions, which are stored in **MinIO**.
9.  The final report is sent over the WebSocket to the frontend's `ReportDisplay.tsx`.

## 6. How to Contribute

This section outlines common development tasks.

### How to Add a New Field to a Project (e.g., "priority")

1.  **Database (`project-service/database.py`):** Add `priority = Column(String(50), default="medium")` to the `ProjectModel` class.
2.  **API Schema (`project-service/schemas.py`):** Add `priority: Optional[str] = None` to the `ProjectCreate` and `ProjectUpdate` Pydantic models, and `priority: str` to the `ProjectResponse` model.
3.  **API Logic (`project-service/main.py`):** The existing code should handle the new field automatically due to how it uses Pydantic models.
4.  **Frontend UI (`frontend/src/views/ProjectsView.tsx`):** Add a new `Select` input for "Priority" in the project creation modal.
5.  **Frontend State (`frontend/src/hooks/useProjects.ts`):** Update the `createProject` function to pass the new `priority` field in the API call.
6.  **Frontend Display:** Add a new column to the projects table to display the priority.

### How to Add a New Tool for an Agent

1.  **Create the Tool Logic:** Create a new Python class or function that performs the desired action (e.g., a tool to get current stock prices). Let's say you create `get_stock_price(ticker: str)` in a new file `backend/app/core/financial_tools.py`.
2.  **Define the CrewAI Tool (`backend/app/core/crew.py`):**
    *   Import your new function.
    *   Create a new class that inherits from `BaseTool`:
        ```python
        from .financial_tools import get_stock_price

        class StockPriceTool(BaseTool):
            name: str = "Stock Price Tool"
            description: str = "Use this tool to get the current stock price for a given ticker symbol."

            def _run(self, ticker: str) -> str:
                return get_stock_price(ticker)
        ```
3.  **Instantiate and Assign the Tool (`backend/app/core/crew.py`):**
    *   Inside `create_assessment_crew()`, create an instance: `stock_tool = StockPriceTool()`.
    *   Add this tool to the `tools` list of the agent that should have access to it (e.g., the `Risk & Compliance Officer`).
4.  **Update the Agent's Goal/Task:** Modify the agent's `goal` or its `Task` description to explicitly mention that it can now use the "Stock Price Tool" to perform financial analysis. This is crucial for the LLM to know the tool exists and when to use it.

---

## 7. Recent Platform Enhancements (2025-07-29)

### New Features Added

**Global Log Pane:**
- Right-side collapsible panel accessible from any page
- Real-time logs for Platform, Agents, and Assessment activities
- Filtering, auto-scroll, and download capabilities
- Maximizable for detailed log analysis

**Service Management:**
- Platform services status panel in Settings
- Real-time health monitoring for all services
- Start/Stop/Restart capabilities for local services
- Live logs for service operations
- Service dependency tracking

**Project History:**
- Complete activity timeline for all project actions
- Detailed metadata for each activity
- Expandable details with JSON data
- Filtering by activity type
- Timestamp tracking for audit purposes

**Enhanced UI Components:**
- Improved navigation and user experience
- Better error handling and loading states
- Responsive design improvements
- Consistent styling across components

### Development Improvements

**Local Development:**
- Comprehensive `localdevstart.md` guide
- Step-by-step service startup instructions
- Troubleshooting section for common issues
- Rancher Desktop specific instructions

**Documentation:**
- `chatlog.md` for conversation history
- Updated architecture documentation
- Enhanced developer guides
- Code organization improvements

### How to Use New Features

**Accessing Logs:**
1. Click the collapsible arrow on the right side of any page
2. Select the log type (Platform/Agents/Assessment)
3. Use filters and controls to customize the view
4. Download logs for offline analysis

**Managing Services:**
1. Go to Settings → Platform Services tab
2. View real-time status of all services
3. Use action buttons to start/stop/restart services
4. Click logs button to view service-specific logs

**Viewing Project History:**
1. Open any project
2. Navigate to the History tab
3. Filter activities by type
4. Expand entries to see detailed information

---

**Happy Coding!**

This guide should provide a solid foundation for understanding and contributing to the AgentiMigrate platform. For any further questions, please refer to the `README.md`, `localdevstart.md`, or the source code itself.