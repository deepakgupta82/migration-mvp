# Nagarro AgentiMigrate - Developer Onboarding Guide

**Welcome to the AgentiMigrate team!** This document is your guide to understanding the platform's architecture, codebase, and development workflows.

## 1. Introduction

AgentiMigrate is a GenAI-powered platform that automates cloud migration assessments. It ingests client documents, uses a team of AI agents to analyze them, and produces a comprehensive migration plan. Our goal is to provide a "Glass Box AI" experience, where the AI's reasoning is transparent and auditable.

## 2. Getting Started: Your First Launch

Your first step is to get the platform running locally. We have a fully automated script that handles everything.

1.  **Clone the repository.**
2.  **Navigate to the root directory.**
3.  **Run the setup script:**
    *   **On Windows (PowerShell):** `.\setup-platform.ps1`
    *   **On macOS/Linux (Bash):** `./build-optimized.sh` (you may need to `chmod +x *.sh` first)

The script will check prerequisites, create a `.env` file, prompt you for an API key, and build/launch all services. For a detailed walkthrough, see the `README.md`.

**Once running, the main access point is the Frontend Command Center: `http://localhost:3000`**

## 3. Codebase Structure

The project is a microservices architecture. Here's a breakdown of the key directories:

```
migration_platform_2/
├── backend/              # The "brains": FastAPI app for agent orchestration & core APIs.
├── frontend/             # The UI: React + TypeScript Command Center.
├── project-service/      # The "memory": FastAPI app for state management (projects, users).
├── reporting-service/    # The "scribe": FastAPI app for generating PDF/DOCX reports.
├── MegaParse/            # Third-party service for document parsing.
├── k8s/                  # Kubernetes manifests for production deployment.
├── docs/                 # All project documentation lives here.
├── logs/                 # Log files generated by the platform.
├── docker-compose.yml    # Defines how all services run and connect locally.
└── setup-platform.ps1    # The main script for setting up the local environment.
```

## 4. Services Deep Dive

### 4.1. `project-service` (The Source of Truth)

This service manages all persistent state. It's the single source of truth for what projects exist, who owns them, and what their status is.

*   **`main.py`**: Defines all FastAPI endpoints for CRUD operations on Projects, Users, Files, Settings, and Deliverables. It handles authentication and authorization.
*   **`database.py`**: Defines the PostgreSQL database schema using SQLAlchemy ORM. If you need to add a field to the `ProjectModel`, you do it here.
*   **`schemas.py`**: Defines the Pydantic models used for API request/response validation. This ensures data consistency.
*   **`auth.py`**: Contains all logic for user authentication (password hashing, JWT creation, token verification).

### 4.2. `backend` (The Orchestrator)

This is where the core AI logic happens. It receives requests from the frontend and orchestrates the other services to perform the assessment.

*   **`main.py`**: The main FastAPI application file.
    *   Defines the crucial WebSocket endpoint `/ws/run_assessment/{project_id}` which manages the entire assessment flow.
    *   Exposes helper APIs like `/api/projects/{project_id}/query` (for the RAG chat) and `/api/projects/{project_id}/graph` (for the graph visualizer).
    *   Contains the logic to call the `project-service` and `reporting-service`.
*   **`core/crew.py`**: The heart of the AI.
    *   **Agent Definitions**: This is where the backstories, goals, and tools for each AI agent (`Engagement Analyst`, `Cloud Architect`, etc.) are defined.
    *   **Task Definitions**: This is where the specific instructions for each agent's tasks are defined.
    *   **`create_assessment_crew()`**: This function assembles the agents and tasks into a `Crew` object, ready for execution.
    *   **`AgentLogStreamHandler`**: A custom callback handler that intercepts agent actions and streams them over the WebSocket for the live console.
*   **`core/rag_service.py`**: Manages all interactions with the Weaviate vector database. It handles chunking text, creating embeddings, and performing semantic queries.
*   **`core/graph_service.py`**: Manages all interactions with the Neo4j graph database. It's used to store and query the IT landscape's "digital twin".
*   **`core/project_service.py`**: A simple client class for making HTTP requests to the `project-service`.

### 4.3. `frontend` (The Command Center)

This is a modern React application built with TypeScript and the Mantine component library.

*   **`src/App.tsx`**: The main entry point, which sets up routing (`react-router-dom`) and the main application layout (`AppLayout`).
*   **`src/views/`**: Contains the top-level components for each "page" or "view" (e.g., `DashboardView.tsx`, `ProjectDetailView.tsx`).
*   **`src/components/`**: Contains reusable components used across different views.
    *   `project-detail/ChatInterface.tsx`: The RAG-powered chat window.
    *   `project-detail/GraphVisualizer.tsx`: The interactive dependency graph.
    *   `project-detail/LiveConsole.tsx`: The real-time log viewer for assessments.
*   **`src/services/api.ts`**: A centralized service for making all API calls to the backend. It uses `axios`.
*   **`src/hooks/useProjects.ts`**: A custom React hook for managing project-related state, abstracting away the data fetching logic from the UI components.

## 5. Data Flow Walkthroughs

Understanding the data flow is key to understanding the system.

### Flow 1: Creating a New Project

1.  **User** fills out the form in `ProjectsView.tsx` and clicks "Create".
2.  The component calls a function from the `useProjects.ts` hook.
3.  The hook calls `apiService.createProject()`.
4.  `apiService` sends a `POST` request to the `backend`'s `/projects` endpoint.
5.  The `backend` endpoint proxies the request to the `project-service`'s `/projects` endpoint.
6.  The `project-service` validates the data, creates a new `ProjectModel` instance, associates it with the current user, and saves it to the **PostgreSQL** database.
7.  The response flows back up the chain to the UI, which updates to show the new project.

### Flow 2: Running an Assessment

1.  **User** uploads files and clicks "Start Assessment" in `FileManagement.tsx`.
2.  The **Frontend** opens a WebSocket connection to the `backend` at `/ws/run_assessment/{project_id}`.
3.  The `backend`'s WebSocket handler begins execution:
    a. It calls the **MegaParse** service to extract text from the uploaded files.
    b. It uses `RAGService` to chunk the text, create vector embeddings, and store them in **Weaviate**.
    c. It uses an AI agent via `RAGService` to extract entities and relationships and stores them in **Neo4j**.
    d. It calls `create_assessment_crew()` to initialize the AI agent team. The `AgentLogStreamHandler` is attached to the crew, pointing to our WebSocket.
4.  The `crew.kickoff()` method is called.
5.  As agents work, the `AgentLogStreamHandler` captures their actions and sends JSON messages over the **WebSocket** to the frontend's `LiveConsole.tsx`.
6.  When finished, the crew returns a final Markdown report.
7.  The `backend` handler saves this report to **PostgreSQL** via the `project-service`.
8.  The `backend` handler calls the **Reporting Service** to generate PDF/DOCX versions, which are stored in **MinIO**.
9.  The final report is sent over the WebSocket to the frontend's `ReportDisplay.tsx`.

## 6. How to Contribute

This section outlines common development tasks.

### How to Add a New Field to a Project (e.g., "priority")

1.  **Database (`project-service/database.py`):** Add `priority = Column(String(50), default="medium")` to the `ProjectModel` class.
2.  **API Schema (`project-service/schemas.py`):** Add `priority: Optional[str] = None` to the `ProjectCreate` and `ProjectUpdate` Pydantic models, and `priority: str` to the `ProjectResponse` model.
3.  **API Logic (`project-service/main.py`):** The existing code should handle the new field automatically due to how it uses Pydantic models.
4.  **Frontend UI (`frontend/src/views/ProjectsView.tsx`):** Add a new `Select` input for "Priority" in the project creation modal.
5.  **Frontend State (`frontend/src/hooks/useProjects.ts`):** Update the `createProject` function to pass the new `priority` field in the API call.
6.  **Frontend Display:** Add a new column to the projects table to display the priority.

### How to Add a New Tool for an Agent

1.  **Create the Tool Logic:** Create a new Python class or function that performs the desired action (e.g., a tool to get current stock prices). Let's say you create `get_stock_price(ticker: str)` in a new file `backend/app/core/financial_tools.py`.
2.  **Define the CrewAI Tool (`backend/app/core/crew.py`):**
    *   Import your new function.
    *   Create a new class that inherits from `BaseTool`:
        ```python
        from .financial_tools import get_stock_price

        class StockPriceTool(BaseTool):
            name: str = "Stock Price Tool"
            description: str = "Use this tool to get the current stock price for a given ticker symbol."

            def _run(self, ticker: str) -> str:
                return get_stock_price(ticker)
        ```
3.  **Instantiate and Assign the Tool (`backend/app/core/crew.py`):**
    *   Inside `create_assessment_crew()`, create an instance: `stock_tool = StockPriceTool()`.
    *   Add this tool to the `tools` list of the agent that should have access to it (e.g., the `Risk & Compliance Officer`).
4.  **Update the Agent's Goal/Task:** Modify the agent's `goal` or its `Task` description to explicitly mention that it can now use the "Stock Price Tool" to perform financial analysis. This is crucial for the LLM to know the tool exists and when to use it.

---

## 7. Recent Platform Enhancements (2025-07-29)

### New Features Added

**Global Log Pane:**
- Right-side collapsible panel accessible from any page
- Real-time logs for Platform, Agents, and Assessment activities
- Filtering, auto-scroll, and download capabilities
- Maximizable for detailed log analysis

**Service Management:**
- Platform services status panel in Settings
- Real-time health monitoring for all services
- Start/Stop/Restart capabilities for local services
- Live logs for service operations
- Service dependency tracking

**Project History:**
- Complete activity timeline for all project actions
- Detailed metadata for each activity
- Expandable details with JSON data
- Filtering by activity type
- Timestamp tracking for audit purposes

**Enhanced UI Components:**
- Improved navigation and user experience
- Better error handling and loading states
- Responsive design improvements
- Consistent styling across components

### Development Improvements

**Local Development:**
- Comprehensive `localdevstart.md` guide
- Step-by-step service startup instructions
- Troubleshooting section for common issues
- Rancher Desktop specific instructions

**Documentation:**
- `chatlog.md` for conversation history
- Updated architecture documentation
- Enhanced developer guides
- Code organization improvements

### How to Use New Features

**Accessing Logs:**
1. Click the collapsible arrow on the right side of any page
2. Select the log type (Platform/Agents/Assessment)
3. Use filters and controls to customize the view
4. Download logs for offline analysis

**Managing Services:**
1. Go to Settings → Platform Services tab
2. View real-time status of all services
3. Use action buttons to start/stop/restart services
4. Click logs button to view service-specific logs

**Viewing Project History:**
1. Open any project
2. Navigate to the History tab
3. Filter activities by type
4. Expand entries to see detailed information

---

**Happy Coding!**

This guide should provide a solid foundation for understanding and contributing to the AgentiMigrate platform. For any further questions, please refer to the `README.md`, `localdevstart.md`, or the source code itself.